<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Market Data Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        .spinner { border: 4px solid rgba(0, 0, 0, 0.1); border-left-color: #3b82f6; border-radius: 50%; width: 1rem; height: 1rem; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body class="text-gray-800">
    <div id="app" class="container mx-auto p-4 max-w-7xl">
        <h1 class="text-3xl font-bold mb-2 text-gray-900">Live Market Visualizer</h1>
        <h2 id="symbol-header" class="text-xl font-semibold text-blue-600 mb-6">Symbol: {{ symbol }}</h2>

        <div class="bg-white p-4 rounded-lg shadow-lg mb-6">
            <div class="flex flex-wrap gap-4 items-end">
                <div>
                    <label for="security-select" class="block text-sm font-medium text-gray-700">Select Security</label>
                    <select id="security-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 rounded-md">
                        <option value="" disabled selected>-- Loading --</option>
                    </select>
                </div>
                <div>
                    <label for="interval-input" class="block text-sm font-medium text-gray-700">Candle Interval</label>
                    <select id="interval-input" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 rounded-md">
                        <option value="1T" selected>1 Minute</option>
                        <option value="5T">5 Minutes</option>
                        <option value="10S">10 Seconds</option>
                    </select>
                </div>
                <div class="flex items-center ml-auto space-x-4">
                     <div class="flex items-center">
                        <input id="history-replay-toggle" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded">
                        <label for="history-replay-toggle" class="ml-2 block text-sm text-gray-900">Run Complete History Replay</label>
                    </div>
                    <div id="status-indicator" class="flex items-center space-x-2">
                        <div class="spinner"></div>
                        <span id="status-text" class="text-sm font-medium text-gray-600">Connecting...</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="bg-white p-4 rounded-lg shadow-lg">
            <div id="trading-chart" style="width: 100%; height: 65vh;"></div>
        </div>
    </div>

    <script>
        // --- DOM Elements & Global State ---
        const symbolHeader = document.getElementById('symbol-header');
        const securitySelect = document.getElementById('security-select');
        const intervalInput = document.getElementById('interval-input');
        const historyReplayToggle = document.getElementById('history-replay-toggle');
        const statusText = document.getElementById('status-text');
        const spinner = document.querySelector('.spinner');
        const chartContainer = document.getElementById('trading-chart');

        let tradingChart = null;
        let socket = null;
        let currentSymbol = '';

        // ECharts data series arrays
        let ecOhlcData = [], ecBubbleData = [], ecNormalBuyVol = [], ecBigBuyVol = [], ecNormalSellVol = [], ecBigSellVol = [];

        // --- Core Functions ---
        const getSymbolFromURL = () => {
            const params = new URLSearchParams(window.location.search);
            return params.get('Symbol') || '{{ symbol }}' || 'DEFAULT_SYMBOL';
        };

        const updateStatus = (text, isLoading = false) => {
            statusText.textContent = text;
            spinner.style.display = isLoading ? 'block' : 'none';
        };

        const resetChartState = () => {
            ecOhlcData = [], ecBubbleData = [], ecNormalBuyVol = [], ecBigBuyVol = [], ecNormalSellVol = [], ecBigSellVol = [];
            if (tradingChart) tradingChart.setOption(getChartOption(), true);
        };

        // --- ECharts Visualization ---
        const drawChart = () => {
            if (tradingChart) tradingChart.dispose();
            tradingChart = echarts.init(chartContainer);
            tradingChart.setOption(getChartOption(), true);
        };

        const getChartOption = () => ({
            animation: false,
            tooltip: { trigger: 'axis', axisPointer: { type: 'cross' } },
            axisPointer: { link: [{ xAxisIndex: 'all' }] },
            grid: [{ height: '50%' }, { top: '68%', height: '16%' }],
            xAxis: [
                { type: 'time', scale: true, axisLine: { onZero: false }, splitLine: { show: false }, axisLabel: { show: false } },
                { type: 'time', gridIndex: 1, scale: true, axisLine: { onZero: false }, splitLine: { show: false } }
            ],
            yAxis: [{ scale: true }, { gridIndex: 1, scale: true, splitNumber: 2, axisLabel: { show: false } }],
            dataZoom: [
                { type: 'inside', xAxisIndex: [0, 1], start: 90, end: 100 },
                { show: true, xAxisIndex: [0, 1], type: 'slider', top: '90%', start: 90, end: 100 }
            ],
            series: [
                { name: 'Candlestick', type: 'candlestick', data: ecOhlcData },
                { name: 'Volume Bubble', type: 'scatter', data: ecBubbleData, symbolSize: data => Math.min(50, Math.max(5, Math.log(data[2] + 1) * 2)) },
                { name: 'Normal Buy', type: 'bar', xAxisIndex: 1, yAxisIndex: 1, data: ecNormalBuyVol, stack: 'Vol', itemStyle: { color: '#86efac'} },
                { name: 'Big Buy', type: 'bar', xAxisIndex: 1, yAxisIndex: 1, data: ecBigBuyVol, stack: 'Vol', itemStyle: { color: '#22c55e'} },
                { name: 'Normal Sell', type: 'bar', xAxisIndex: 1, yAxisIndex: 1, data: ecNormalSellVol, stack: 'Vol', itemStyle: { color: '#fca5a5'} },
                { name: 'Big Sell', type: 'bar', xAxisIndex: 1, yAxisIndex: 1, data: ecBigSellVol, stack: 'Vol', itemStyle: { color: '#ef4444'} }
            ]
        });

        const updateChartLive = () => {
            if (!tradingChart) return;
            tradingChart.setOption({
                series: [
                    { data: ecOhlcData }, { data: ecBubbleData }, { data: ecNormalBuyVol },
                    { data: ecBigBuyVol }, { data: ecNormalSellVol }, { data: ecBigSellVol }
                ]
            });
        };

        // --- WebSocket Connection & Logic ---
        const connectSocket = () => {
            socket = io('/bubble'); // Connect to the '/bubble' namespace

            socket.on('connect', () => {
                updateStatus('Connected. Requesting data...', true);
                const historyLoaded = sessionStorage.getItem(`${currentSymbol}_history_loaded`) === 'true';
                socket.emit('request_data', {
                    symbol: currentSymbol,
                    loaded: historyLoaded,
                    interval: intervalInput.value,
                    threshold: 20, // Example value
                    bigPlayerThreshold: 50 // Example value
                });
            });

            socket.on('disconnect', () => updateStatus('Disconnected.', false));

            socket.on('available_securities', (data) => {
                securitySelect.innerHTML = '';
                data.securities.forEach(id => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = id;
                    if (id === currentSymbol) option.selected = true;
                    securitySelect.appendChild(option);
                });
            });

            socket.on('historical_data', (msg) => {
                if (msg.securityId !== currentSymbol) return;

                // This is the first time we load historical data for this session
                sessionStorage.setItem(`${currentSymbol}_history_loaded`, 'true');

                ecOhlcData = msg.data.ohlc;
                ecBubbleData = msg.data.bubble;
                ecNormalBuyVol = msg.data.normalBuy;
                ecBigBuyVol = msg.data.bigBuy;
                ecNormalSellVol = msg.data.normalSell;
                ecBigSellVol = msg.data.bigSell;

                updateChartLive();
                updateStatus(`Live: ${currentSymbol}`, false);
            });

            socket.on('live_update', (msg) => {
                if (msg.securityId !== currentSymbol || !msg.lastCandle) return;
                const lc = msg.lastCandle;
                const lastCandleIndex = ecOhlcData.length - 1;

                if (lastCandleIndex >= 0 && ecOhlcData[lastCandleIndex][0] === lc.time) {
                    ecOhlcData[lastCandleIndex] = [lc.time, lc.open, lc.close, lc.low, lc.high];
                    ecNormalBuyVol[lastCandleIndex] = [lc.time, lc.buyVolume];
                    ecBigBuyVol[lastCandleIndex] = [lc.time, lc.bigPlayerBuyVolume];
                    ecNormalSellVol[lastCandleIndex] = [lc.time, -lc.sellVolume];
                    ecBigSellVol[lastCandleIndex] = [lc.time, -lc.bigPlayerSellVolume];
                } else {
                    ecOhlcData.push([lc.time, lc.open, lc.close, lc.low, lc.high]);
                    ecNormalBuyVol.push([lc.time, lc.buyVolume]);
                    ecBigBuyVol.push([lc.time, lc.bigPlayerBuyVolume]);
                    ecNormalSellVol.push([lc.time, -lc.sellVolume]);
                    ecBigSellVol.push([lc.time, -lc.bigPlayerSellVolume]);
                }
                ecBubbleData = msg.bubbles;
                updateChartLive();
            });

            socket.on('message', (msg) => {
                // Generic handler for different actions from the new logic
                if (msg.symbol !== currentSymbol) return;

                if (msg.action === 'historical') {
                    // Assuming server sends one tick at a time for replay
                    // (This part needs client-side aggregation if not done on server)
                    console.log('Historical tick:', msg.data);
                    // For now, we assume server sends aggregated historical data
                } else if (msg.action === 'live') {
                    // This path is now handled by 'live_update'
                }
            });
        };

        // --- Event Handlers ---
        const handleStreamRequest = () => {
            currentSymbol = securitySelect.value;
            if (!currentSymbol) return;

            // Update URL without reloading page
            const url = new URL(window.location);
            url.searchParams.set('Symbol', currentSymbol);
            window.history.pushState({}, '', url);
            symbolHeader.textContent = `Symbol: ${currentSymbol}`;

            resetChartState();
            if (socket) socket.disconnect();
            connectSocket();
        };

        securitySelect.addEventListener('change', handleStreamRequest);
        intervalInput.addEventListener('change', handleStreamRequest);

        historyReplayToggle.addEventListener('change', () => {
            if (historyReplayToggle.checked) {
                if (!socket || !currentSymbol) {
                    alert("Please select a symbol first.");
                    historyReplayToggle.checked = false;
                    return;
                }
                updateStatus(`Requesting history replay for ${currentSymbol}...`, true);
                resetChartState();
                // Send replay request to server
                socket.emit('replay_history', { symbol: currentSymbol });
            }
        });

        window.addEventListener('resize', () => tradingChart?.resize());

        // --- Initialization ---
        window.onload = () => {
            currentSymbol = getSymbolFromURL();
            symbolHeader.textContent = `Symbol: ${currentSymbol}`;
            drawChart();
            connectSocket();
        };
    </script>
</body>
</html>